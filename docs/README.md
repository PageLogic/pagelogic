---
description: An HTML-based reactive web framework, for Node.js and the browser
---

# PageLogic

PageLogic brings reactive web development, popularized by [React](https://react.dev/), [Vue](https://vuejs.org/), and [Angular](https://angular.io/), to HTML itself.

It aims to remove the complexity and boilerplate of reactive frameworks, while retaining the advantages of reactivity and componentization.

It augments HTML with:

* [logic values](concepts/html-extensions.md#logic-values), specified with `:`-prefixed attributes
* [reactive expressions](concepts/html-extensions.md#reactive-expressions), wrapped in `{...}` clauses
* [visibility scopes](concepts/html-extensions.md#visibility-scopes), associated to elements with logic values
* [directives](concepts/html-extensions.md#directives), declared as `<:...>` tags and used to modularize code.

### Hello World

{% code title="www/index.html" %}
```html
<html>
  <body>
    <button :count={0} :on-click={() => count++}>
      Clicks: {count}
    </button>
  </body>
</html>
```
{% endcode %}

```bash
npm install -g pagelogic
pagelogic serve ./www
# http://127.0.0.1:3000
```

#### How it works

* Because it declares logic values, `<button>` has its own scope, which includes the property `count`.
* The `{count}` expression lives in the same scope, and references the property. Since it’s reactive, it’s automatically updated whenever it changes.
* This happens when users click the button, thanks to the `on-click` event listener.
* The page is served complete with its initial content "Clicks: 0": page logic [starts in the server and continues in the client](concepts/isomorphism-and-ssr.md) by default.

When served through PageLogic server, pages are compiled on the fly. In development mode, pages are recompiled automatically and the browser is refreshed when they change.

{% hint style="success" %}
This is a complete working example: all the boilerplate required by traditional frameworks is removed, and only what's relevant for the actual page logic remains.
{% endhint %}

#### Pre compilation

If you don't want to use the included server (and don't need SSR), you can pre compile PageLogic pages:

```bash
pagelogic build ./www ./dist
```

The compiler includes a copy of PageLogic runtime, and for each page generates standard HTML plus some page-specific code which implements page behavior.

### Why PageLogic

* **Zero boilerplate** — forget ceremonies like React's `useState()`, `render()` etc. PageLogic handles these details behind the scenes, keeping your code clean and expressive.
* **Zero dependencies** — compiled pages only need their namesake JavaScript file, implementing page logic, and the PageLogic runtime, both generated by the compiler or the server.
* **Super lightweight** — because runtime, compiler and server were designed together, it sports a tiny size of less than 3kB (minified, compressed) in the browser.
* **No Virtual DOM** — PageLogic uses direct DOM reflection, a much lighter and efficient solution.
* **Isomorphic by design** — with other frameworks, delivering content-ready pages for search engine indexing can be complex: PageLogic server does it by default.
* **Advanced routing** — the same set of pages can work as a classic website and as a modern [SPA](https://en.wikipedia.org/wiki/Single-page\_application) at the same time.
* **Simple components** — going from a simple block of code to a reusable component is trivial and promotes building your own reusable libraries.
* **Flexible deployment** — PageLogic pages can be served using its own [Node.js](https://nodejs.org/) server or its [Express](https://expressjs.com/) middleware in your own projects, or can be used as pre compiled HTML.
