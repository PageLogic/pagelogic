# PageLogic

[![CodeQL](https://github.com/fcapolini/pagelogic/actions/workflows/codeql.yml/badge.svg)](https://github.com/fcapolini/pagelogic/actions/workflows/codeql.yml)
[![Node.js CI](https://github.com/fcapolini/pagelogic/actions/workflows/node.js.yml/badge.svg)](https://github.com/fcapolini/pagelogic/actions/workflows/node.js.yml)

> An HTML-based, isomorphic, reactive web framework.

Modern web development is mostly done using some reactive framework, like [React](https://react.dev/), [Vue](https://vuejs.org/) or [Angular](https://angular.io/). This has many advantages, but they all add plenty of complexity and make the experience closer to desktop development.

PageLogic aims to restore simplicity while preserving the benefits of modern frameworks. It extends HTML with `<:...>` [directive tags](), `:...` [logic attributes](), and `${...}` [reactive expressions]() to let you write modular, reactive logic directly in HTML.

## Hello world

This is a minimal but complete PageLogic page:

```jsx
<html>
<body>
  <button :count=${0}
          :on-click=${() => count++}>
    Clicks: ${count}
  </button>
</body>
</html>
```

We'll save it as `index.html` in `./www`. We can now install PageLogic and serve it like this:

```bash
npm i -g pagelogic
pagelogic serve www
# address http://127.0.0.1:3000/
```

Alternatively we can statically compile with `pagelogic build` and use the generated HTML pages. Our example will generate a `index.html` + `index.js` pair of files which, together, implement page behaviour. The compiler will also generate a `pagelogic-rt.js` file in the destination directory, containing the PageLogic runtime used by all compiled pages.

## Why PageLogic

* **Zero boilerplate** &mdash; forget all the obscure cerimonies like React's `useState()` etc.: PageLogic handles these details behind the scenes, keeping your code clean.

* **Zero dependencies** &mdash; PageLogic pages only need their namesake JavaScript file, implementing page logic, and the PageLogic runtime, both generated by the compiler or the server.

* **No Virtual DOM** &mdash; PageLogic uses direct DOM reflection, a much lighter and efficient solution.

* **Isomorphic by design** &mdash; with other frameworks, delivering content-ready pages for search engine indexing can be complex: PageLogic's server does it by default.

* **Super lightweight** &mdash; because runtime, compiler and server were designed together, it sports a tiny size of less than 3kB (minified, gzipped) in the browser.

* **Flexible deployment** &mdash; PageLogic pages can be served using its own [Node.js](https://nodejs.org/) server, its [Express](https://expressjs.com/) middleware in the context of your project, or as static precompiled HTML pages.

* **Advanced routing** &mdash; the same set of pages can work as a classic website and as a modern [SPA](https://en.wikipedia.org/wiki/Single-page_application) at the same time.

* **Simple components** &mdash; moving from a simple block of code to a reusable component is trivial and you can effortlessly build your own reusable libraries over time.
